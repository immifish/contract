// SPDX-License-Identifier: MIT

pragma solidity =0.8.29;

import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import "./interface/IBlockUpdater.sol";
import "./interface/IMinerToken.sol";

//todo 还需要增加factory, 通过factory来铸造protfolio 
// 针对不同的情况可以有不同的方法，甚至可以直接平仓？？
// make a erc20 compatible contract
contract MinerToken is Initializable, IMinerToken, ERC20Upgradeable, OwnableUpgradeable {
    using Address for address;

    event DesignatedBeneficiaryUpdated(address indexed settlor, address indexed beneficiary, address indexed operator);

    /// @notice works for both creditor and debtor
    /// @param lastModifiedEpoch The epoch when this snapshot was last updated
    /// @param lastModifiedTime The timestamp when this snapshot was last updated  
    struct TimeStamp {
        uint256 lastModifiedEpoch;
        uint256 lastModifiedTime;
    }
    
    /// @notice A snapshot represents either a creditor or debtor position
    /// @dev For creditors, interestOrDebt tracks earned interest
    /// @dev For debtors, interestOrDebt tracks outstanding debt
    /// @param interestOrDebt is the interest or debt amount that are settled
    /// @param interestOrDebtFactor is the pending interest / debt factor as the reward factor is not updated yet
    struct Snapshot {
        uint256 interestOrDebt;
        uint256 interestOrDebtFactor;
    }

    mapping(address => Snapshot) _creditors;
    mapping(address => Snapshot) _debtors;
    /// @notice Tracks addresses that have minted (borrowed) tokens, i.e. portfolio contract addresses
    mapping(address account => uint256) _balancesNeg;
    mapping(address => TimeStamp) _timeStamps;
    // most contract can not claim interest as creditor, so we need to designate a beneficiary
    mapping(address => address) _designatedBeneficiary;
    IERC20 _interestToken;
    IBlockUpdater _blockUpdater;

    // Decimals for the token
    uint8 _decimals;

    // Initializer function to set up the token
    function initialize(
        string memory name_,
        string memory symbol_,
        uint8 decimals_,
        address interestToken_,
        address blockUpdater_
    ) public initializer {
        __ERC20_init(name_, symbol_);
        _decimals = decimals_;
        __Ownable_init(msg.sender);   // Initialize the Ownable contract with the deployer as the owner
        _interestToken = IERC20(interestToken_); // Set the interest token address
        _blockUpdater = IBlockUpdater(blockUpdater_);
    }

    // Override the decimals function to return the custom decimals value
    function decimals() public view override returns (uint8) {
        return _decimals;
    }

    function interestToken() public view override returns (address) {
        return address(_interestToken);
    }

    // reserved for upgrade
    function setBlockUpdater(address _newBlockUpdater) public onlyOwner {
        _blockUpdater = IBlockUpdater(_newBlockUpdater);
    }

    function blockUpdater() public view override returns (address) {
        return address(_blockUpdater);
    }

    // redirect the interest to designated beneficiary. The beneficiary can claim interest for the settlor
    function setDesignatedBeneficiary(address _settlor, address _beneficiary) public {
        require(_settlor != address(0), "MinerToken: settlor cannot be zero address");
        require(_beneficiary != address(0), "MinerToken: beneficiary cannot be zero address");
        
        if (_msgSender() == _settlor || _msgSender() == owner()) {
            _designatedBeneficiary[_settlor] = _beneficiary;
            emit DesignatedBeneficiaryUpdated(_settlor, _beneficiary, _msgSender());
        } else {
            revert("MinerToken: caller must be settlor or owner");
        }
    }

    function getDesignatedBeneficiary(address _settlor) public view returns (address) {
        return _designatedBeneficiary[_settlor];
    }

    function _settleAndUpdateSnapshot2(address _address) internal {
        TimeStamp storage timeStamp = _timeStamps[_address];
        // call multiple times in one transaction will not update the snapshot
        if (block.timestamp == timeStamp.lastModifiedTime) {
            return;
        }
        uint256 balance = balanceOf(_address);
        uint256 balanceNeg = _balancesNeg[_address];
        Snapshot storage creditorSnapshot = _creditors[_address];
        Snapshot storage debtorSnapshot = _debtors[_address];
        bool isNegProductivity = balanceNeg > balance;
        // because the creditor and debtor always update at once, so the diff of
        // interestOrDebt and interestOrDebtFactor will have the same sign
        uint256 diff = isNegProductivity ? balanceNeg - balance : balance - balanceNeg;
        uint256 diffFactor = isNegProductivity ? 
        debtorSnapshot.interestOrDebtFactor - creditorSnapshot.interestOrDebtFactor : 
        creditorSnapshot.interestOrDebtFactor - debtorSnapshot.interestOrDebtFactor;
        (uint256 epochReward, uint256 pendingInterestOrDebtFactor) = _blockUpdater
            .pendingReward(
                diff,
                timeStamp.lastModifiedEpoch,
                timeStamp.lastModifiedTime,
                diffFactor
            );
        
    }

    // it works for both creditor and debtor
    function _settleAndUpdateSnapshot(address _address) internal {
        TimeStamp storage timeStamp = _timeStamps[_address];
        // call multiple times in one transaction will not update the snapshot
        if (block.timestamp == timeStamp.lastModifiedTime) {
            return;
        }

        Snapshot storage creditorSnapshot = _creditors[_address];
        uint256 interestBeforeRebalance;
        uint256 balance = balanceOf(_address);
        if (balance > 0){
            (uint256 epochReward, uint256 pendingInterestOrDebtFactor) = _blockUpdater
            .pendingReward(
                balance,
                timeStamp.lastModifiedEpoch,
                timeStamp.lastModifiedTime,
                creditorSnapshot.interestOrDebtFactor
            );
            interestBeforeRebalance = creditorSnapshot.interestOrDebt + epochReward;
            creditorSnapshot.interestOrDebtFactor = pendingInterestOrDebtFactor;
        }

        Snapshot storage debtorSnapshot = _debtors[_address];
        uint256 debtBeforeRebalance;
        uint256 balanceNeg = _balancesNeg[_address];
        if (balanceNeg > 0){
            (uint256 epochReward, uint256 pendingInterestOrDebtFactor) = _blockUpdater
            .pendingReward(
                balanceNeg,
                timeStamp.lastModifiedEpoch,
                timeStamp.lastModifiedTime,
                debtorSnapshot.interestOrDebtFactor
            );
            debtBeforeRebalance = debtorSnapshot.interestOrDebt + epochReward;
            debtorSnapshot.interestOrDebtFactor = pendingInterestOrDebtFactor;
        }

        if (interestBeforeRebalance > debtBeforeRebalance){
            debtorSnapshot.interestOrDebt = 0;
            creditorSnapshot.interestOrDebt = interestBeforeRebalance - debtBeforeRebalance;
        }else{
            debtorSnapshot.interestOrDebt = debtBeforeRebalance - interestBeforeRebalance;
            creditorSnapshot.interestOrDebt = 0;
        }

        timeStamp.lastModifiedTime = block.timestamp;
        if (timeStamp.lastModifiedEpoch != _blockUpdater.getCurrentEpoch()) {
            timeStamp.lastModifiedEpoch = _blockUpdater.getCurrentEpoch();
        }
    }

    // claim interest of creditor, can call by owner or designated beneficiary
    function claim(address _creditor, address _to, uint256 _amount) external {
        if (msg.sender == _creditor || msg.sender == _designatedBeneficiary[_creditor]) {
            _settleAndUpdateSnapshot(_creditor);
            if (_creditors[_creditor].interestOrDebt < _amount) {
                revert MinerTokenInsufficientInterest(_creditor, _creditors[_creditor].interestOrDebt, _amount);
            }
            unchecked {
                _creditors[_creditor].interestOrDebt -= _amount;
            }
            _interestToken.transfer(_to, _amount);
            emit ClaimReward(_creditor, _to, _amount);
        } else {
            revert("MinerToken: caller must be creditor or designated beneficiary");
        }
    }
    
    function transfer(address to, uint256 value) public override returns (bool) {
        address owner = _msgSender();
        _settleAndUpdateSnapshot(owner);
        _settleAndUpdateSnapshot(to);
        _transfer(owner, to, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public override returns (bool) {
        address spender = _msgSender();
        _spendAllowance(from, spender, value);
        _settleAndUpdateSnapshot(from);
        _settleAndUpdateSnapshot(to);
        _transfer(from, to, value);
        return true;
    }

    // this can only be called by debtor address
    function burn(uint256 amount) external {
        require(amount > 0, "MinerToken: burn amount must be greater than 0");
        address owner = _msgSender();
        uint256 balanceNeg = _balancesNeg[owner];
        uint256 balance = balanceOf(owner);
        if (balanceNeg < amount) {
            revert("MinerToken: insufficient debtor balance");
        }
        if (balance < amount) {
            revert("MinerToken: insufficient creditor balance");
        }
        _settleAndUpdateSnapshot(owner);
        unchecked {
            _balancesNeg[owner] -= amount;
        }
        _burn(owner, amount);
        emit Burn(owner, amount);
    }

    // should be called by portfolio contract
    function calculateInterestReserve(address _debtor) public view returns (uint256 amount, uint256 inDebt) {
        TimeStamp storage timeStamp = _timeStamps[_debtor];
        //simulate a settle result
        
    }
}
