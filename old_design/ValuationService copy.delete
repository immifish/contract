// SPDX-License-Identifier: MIT

pragma solidity =0.8.29;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "./lib/AddressArray.sol";
import "./interface/IPriceOracle.sol";

contract ValuationService is Initializable, OwnableUpgradeable, UUPSUpgradeable {
    using AddressArray for address[];

    IPriceOracle public priceOracle;
    // Loan (token) To Value (of collateral) => LTV (e.g. [USDC][F(BTC,20)] = 8000 -> 80%)
    mapping(address => mapping(address => uint256)) public LTV;
    uint256 public constant EFFICIENCY_DENOMINATOR = 10000;
    // List of accepted tokens that can be counted in value to filter(miner token)
    mapping(address => address[]) private whitelist;

    // Initializer function to replace constructor
    function initialize(address _oracleRegister) public initializer {
        __Ownable_init(msg.sender);
        __UUPSUpgradeable_init();
        priceOracle = IPriceOracle(_oracleRegister);
    }

    // Override _authorizeUpgrade to restrict upgradeability to the owner
    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}

    function queryWhitelist(address _loanAsset) public view returns (address[] memory) {
        return whitelist[_loanAsset];
    }

    function setOracleRegister(address _oracleRegister) public onlyOwner {
        priceOracle = IPriceOracle(_oracleRegister);
    }

    // set LTV for loan asset and collateral asset
    function setLTV(address _loanAsset, address _collateralAsset, uint256 _LTV, bool _isValid) public onlyOwner {
        // do not allow 0 address and same address
        require(_loanAsset != address(0) && _collateralAsset != address(0), "Invalid asset address");
        require(_loanAsset != _collateralAsset, "Loan asset and collateral asset cannot be the same");
        if (_isValid) {
            LTV[_loanAsset][_collateralAsset] = _LTV;
            // add to whitelist
            (bool hasAsset, ) = whitelist[_loanAsset].find(_collateralAsset);
            if (!hasAsset) {
                whitelist[_loanAsset].push(_collateralAsset);
            }
        } else {
            LTV[_loanAsset][_collateralAsset] = 0;
            // remove from whitelist
            whitelist[_loanAsset].remove(_collateralAsset);
        }
    }

    function queryPrice(
        address _inputToken,
        address _baseToken,
        uint256 _tokenAmount
    ) public view returns (uint256) {
        return priceOracle.getPrice(_inputToken, _baseToken, _tokenAmount);
    }

    function queryPriceLTV(
        address _inputToken,  //_collateralAsset
        address _baseToken,   //_loanAsset
        uint256 _tokenAmount
    ) public view returns (uint256) {
        if (_inputToken == _baseToken) {
            return _tokenAmount;
        } else {
            uint256 price = priceOracle.getPrice(_inputToken, _baseToken, _tokenAmount);
            price =
                (price * LTV[_baseToken][_inputToken]) /
                EFFICIENCY_DENOMINATOR;
            return price;
        }
    }    

    function queryCollateralValue(
        address _loanAsset,
        address _baseToken,
        address _holder
    ) public view returns (uint256 sum) {
        address[] storage inputTokens = whitelist[_loanAsset];
        for (uint256 i = 0; i < inputTokens.length; ) {
            sum += queryPriceLTV(inputTokens[i], _baseToken, IERC20(inputTokens[i]).balanceOf(_holder));
            unchecked { i++; }
        }
        sum += IERC20(_loanAsset).balanceOf(_holder);
    }
}
